排序：
    选择排序、冒泡排序、插入排序
    归并排序
        归并排序的扩展
            小和问题：在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和
            逆序对问题： 在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对
    快排
        问题一：
            给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)
        问题二：
            给定一个数组arr,和一个数num，请把小雨num的数放在数组的右边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)
        不改进的快速排序
            把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部分：左侧 < 划分值，中间 == 划分值，右侧 > 划分值
            对左侧范围和右侧范围，递归执行
            分析：
                划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低
                可以轻而易去的举出最差的例子，所以不改进的快速排序时间复杂度为O(N^2)
    堆排
        堆结构就是用数组实现的完全二叉树结构
        完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
        完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
        堆结构的heapInsert与heapify操作
        堆结构的增大和减少
        优先级队列结构，就是堆结构 ？
    [排序](image.png)

    桶排序思想下的排序：
        计数排序
            计数排序在要求排序关键字少，重复元素多的时候表现良好；
        基数排序
            基数排序相比较于计数排序而言，减少了桶的个数
        分析：桶排序思想下的排序都是不基于比较的排序
        时间复杂度为O(N),额外空间负载度O(M)
        应用范围有限，需要样本的数据状况满足桶的划分
    排序算法的稳定性及其汇总
        同样值的个体之间，如果不因为排序而改变相对次序，就说这个排序是有稳定性的，否则就没有
        不具备稳定性的排序：
            选择排序、快速排序、堆排序
        具备稳定性的排序：
            冒泡排序、插入排序、归并排序、一切桶排序思想下的排序
        目前没有找到时间复杂度O(N * logN) 空间复杂度O(1) 又稳定的排序

有序表
    有序表在使用层面上可以理解为一种集合结构
    如果只有key，没有伴随数据value，可以使用TreeSet结构（c++中叫OrderedSet）
    如果既有key，又有伴随数据value，可以使用TreeMap结构（c++中叫RederedMap）
    有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事
    有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织
    红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同
    放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
    放入哈希表的东西，如果不是基础数据类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小
    不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度

    有序表的固定操作：
        1、vodi put(key, value)：将一个(key, value)记录加入到表中，或者将key的记录更新成value
        2、get(key): 根据给定的key，查询value并返回
        3、remove(key): 移除key的记录
        4、containsKey(key): 询问是否有关于key的记录
        5、firstKey(): 返回所有键值的排序结果中，最左（最小）的那个
        6、lastKey(): 返回所有键值的排序结果中，最右（最大）的那个
        7、floorKey(key): 如果表中存入过key，返回key，否则返回所有键值的排序结果中，key的前一个
        8、ceilingKey(key): 如果表中存入过key，返回key，否则返回所有键值的排序结果中，key的后一个
        以上所有操作时间复杂度都是O(logN),N为有序表含有的记录数

数组：
    滑动窗口、双指针
链表
    单链表、双链表、循环链表、环形链表

    题目：
        反转单链表和双链表
        打印两个有序链表的公共部分
        判断一个链表是否为回文结构
        将单项链表按某值（pivot）划分成左边小，中间相等，右边大的形式
            进阶：在实现原问题功能的基础上增加如下的要求：
                要求调整后所有小于pivot的节点之间的相对顺序和调整前一样
                调整后所有等于pivot的节点之间的相对顺序和调整前一样
                调整后所有大于pivot的节点之间的相对顺序和调整钱一样
                时间复杂度O(N)，额外空间复杂度O(1)
        复制含有随机指针节点的链表
        两个单链表相交的一系列问题
            给定两个可能有环也可能无环的单链表，头节点head1和head2，请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不想交，返回null
        合并链表、找两个链表的重复部分的第一个节点、找链表的入环节点

    借助栈、哈希表、队列、快慢指针等辅助结构解决问题
二叉树
    先序、中序、后序